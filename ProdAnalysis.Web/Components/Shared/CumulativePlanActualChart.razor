@using System.Globalization
@using ProdAnalysis.Application.Dtos.Hourly

<div style="border:1px solid #ddd; border-radius:8px; padding:12px;">
    <div style="display:flex; gap:12px; align-items:baseline; flex-wrap:wrap;">
        <div style="font-weight:700;">График: накопительно Plan vs Actual</div>
        <div style="color:#666; font-size:13px;">(по 8 часам смены)</div>
        <div style="margin-left:auto; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
            <div style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:14px; height:3px; background:#1f77b4;"></span>
                <span style="font-size:13px;">Plan</span>
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
                <span style="display:inline-block; width:14px; height:3px; background:#ff7f0e;"></span>
                <span style="font-size:13px;">Actual</span>
            </div>
        </div>
    </div>

    @if (Points.Count <= 1)
    {
        <div style="margin-top:10px; color:#666;">Недостаточно данных для графика.</div>
    }
    else
    {
        <div style="margin-top:10px;">
            <svg viewBox="0 0 900 260" style="width:100%; height:auto; display:block;">
                @foreach (var y in GridY)
                {
                    <line x1="@PlotLeft" y1="@y" x2="@PlotRight" y2="@y" stroke="#eee" stroke-width="2" />
                }

                <line x1="@PlotLeft" y1="@PlotTop" x2="@PlotLeft" y2="@PlotBottom" stroke="#ccc" stroke-width="2" />
                <line x1="@PlotLeft" y1="@PlotBottom" x2="@PlotRight" y2="@PlotBottom" stroke="#ccc" stroke-width="2" />

                <path d="@PlanPath" fill="none" stroke="#1f77b4" stroke-width="4" />
                <path d="@ActualPath" fill="none" stroke="#ff7f0e" stroke-width="4" />

                @foreach (var p in Points)
                {
                    <circle cx="@p.X" cy="@p.PlanY" r="4" fill="#1f77b4"></circle>
                    <circle cx="@p.X" cy="@p.ActualY" r="4" fill="#ff7f0e"></circle>
                }

                @for (var i = 0; i < 9; i++)
                {
                    var x = PlotLeft + (PlotWidth * i / 8.0);
                    <line x1="@x" y1="@PlotBottom" x2="@x" y2="@(@PlotBottom + 8)" stroke="#ccc" stroke-width="2" />
                    @((MarkupString)$"<text x=\"{F(x)}\" y=\"{F(PlotBottom + 28)}\" text-anchor=\"middle\" font-size=\"14\" fill=\"#666\">{i}</text>")
                }

                @((MarkupString)$"<text x=\"{F(PlotLeft)}\" y=\"{F(PlotTop - 10)}\" font-size=\"14\" fill=\"#666\">cum qty</text>")
            </svg>
        </div>
    }
</div>

@code {
    [Parameter] public IReadOnlyList<HourlyRecordDto> HourlyRecords { get; set; } = Array.Empty<HourlyRecordDto>();

    private const double PlotLeft = 60;
    private const double PlotRight = 880;
    private const double PlotTop = 20;
    private const double PlotBottom = 220;

    private static double PlotWidth => PlotRight - PlotLeft;
    private static double PlotHeight => PlotBottom - PlotTop;

    private List<Point> Points { get; set; } = new();
    private List<double> GridY { get; set; } = new();

    private string PlanPath { get; set; } = "";
    private string ActualPath { get; set; } = "";

    protected override void OnParametersSet()
    {
        Build();
    }

    private void Build()
    {
        Points.Clear();
        GridY.Clear();
        PlanPath = "";
        ActualPath = "";

        if (HourlyRecords == null || HourlyRecords.Count == 0)
            return;

        var hrs = HourlyRecords.OrderBy(x => x.HourIndex).ToList();

        var cumPlan = new int[9];
        var cumActual = new int[9];

        cumPlan[0] = 0;
        cumActual[0] = 0;

        for (var i = 0; i < 8; i++)
        {
            cumPlan[i + 1] = hrs[i].CumPlanAfterThisHour;
            cumActual[i + 1] = hrs[i].CumActualAfterThisHour;
        }

        var max = 0;
        for (var i = 0; i < 9; i++)
        {
            if (cumPlan[i] > max) max = cumPlan[i];
            if (cumActual[i] > max) max = cumActual[i];
        }

        if (max < 1) max = 1;

        var yMax = max;

        for (var gi = 0; gi <= 4; gi++)
        {
            var frac = gi / 4.0;
            var y = PlotBottom - PlotHeight * frac;
            GridY.Add(y);
        }

        for (var i = 0; i < 9; i++)
        {
            var x = PlotLeft + PlotWidth * i / 8.0;

            var py = PlotBottom - PlotHeight * cumPlan[i] / yMax;
            var ay = PlotBottom - PlotHeight * cumActual[i] / yMax;

            Points.Add(new Point(x, py, ay));
        }

        PlanPath = ToPath(Points.Select(p => (p.X, p.PlanY)));
        ActualPath = ToPath(Points.Select(p => (p.X, p.ActualY)));
    }

    private static string ToPath(IEnumerable<(double x, double y)> pts)
    {
        var list = pts.ToList();
        if (list.Count == 0)
            return "";

        var s = $"M {F(list[0].x)} {F(list[0].y)}";
        for (var i = 1; i < list.Count; i++)
            s += $" L {F(list[i].x)} {F(list[i].y)}";
        return s;
    }

    private static string F(double v)
    {
        return v.ToString("0.###", CultureInfo.InvariantCulture);
    }

    private sealed record Point(double X, double PlanY, double ActualY);
}
